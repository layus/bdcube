\documentclass[10pt,a4paper]{beamer}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{algorithmic}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{positioning, shapes}
\usetikzlibrary{trees,calc}
\usepackage{fancybox}
\usepackage{tikz-qtree}
\usepackage{amsfonts}
\usepackage{amssymb}
\author{Guillaume Maudoux \& CÃ©dric Libert}
\title{Symbolic search}
\setbeamertemplate{navigation symbols}{%
}

\renewcommand{\t}[1]{\text{#1}}

\begin{document}
\tikzstyle{line} = [draw, -latex']
\tikzstyle{feuille} = [rectangle]
\tikzstyle{decision} = [rectangle, draw, fill=gray!20, align=center,
     text centered, minimum height=1cm,minimum width=1cm, node distance=1cm]	
\maketitle
\begin{frame}
\tableofcontents
\end{frame}
\section{Intro}
\begin{frame}
\frametitle{The problem of storing many states}

The list of states still to explore in a classcial search can be very space-consuming (exponential in BFS).  One solution is to use DFS, but then memory usage is suboptimal.  We explore another structure able to store many states in a compressed way: the binary decision diagrams.

\end{frame}

\begin{frame}[t]
\frametitle{Binary decision diagrams encode boolean functions}

Boolean function: $F:\{0,1\}^n \rightarrow \{0,1\}$\\[0.5cm]
BDDs seen as reduced decision trees\\[0.5cm]
 \begin{center}
$a\vee (\neg b \wedge \neg c) \rightarrow a$
 \end{center}\pause

  \begin{overlayarea}{6cm}{1cm}
  	\only<2-3>{\begin{tikzpicture}
[every tree node/.style={draw,circle},
   level distance=1.25cm,sibling distance=.5cm, 
   edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}]
\Tree [.\node(a) {a}; 
     \edge node[auto=right] {1};[.\node (b) {b};
        \edge node[auto=right] {1};[.c 
           \edge node[auto=right] {1}; [.\node[feuille] (t1) {1}; ] \edge node[auto=left] {0}; [.\node[feuille] (t2) {1}; ] 
        ]      
        \edge node[auto=left] {0};[.c 
          \edge node[auto=right] {1}; [.\node[feuille] (t3) {1}; ] \edge node[auto=left] {0}; [.\node[feuille] (t4) {1}; ] 
        ] 
    ]
      \edge node[auto=left] {0}; [.b
        \edge node[auto=right] {1}; [.c 
          \edge node[auto=right] {1}; [.\node[feuille] {1}; ] \edge node[auto=left] {0}; [.\node[feuille] {1}; ] 
        ] 
        \edge node[auto=left] {0}; [.c 
          \edge node[auto=right] {1}; [.\node[feuille] {1}; ] \edge node[auto=left] {0}; [.\node[feuille]{0}; ] 
        ]
    ] ]
        \onslide<3>{\draw[red,thick,dotted] ($(t1.north west)+(-0.3,0.3)$)  rectangle ($(t4.south east)+(0.3,-0.3)$);}
\end{tikzpicture}}
\only<4-5>{\begin{tikzpicture}
[every tree node/.style={draw,circle},
   level distance=1.25cm,sibling distance=.5cm, 
   edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}]
\Tree [.\node (a) {a}; 
     \edge[white] node[auto=right] {1};[.\node[white] (b) {1};
        \edge[white];[.\node[white] (c) {c}; 
           \edge[white] node[auto=right] {1}; [.\node[feuille,white] (t1) {1}; ] \edge[white] node[auto=left] {0}; [.\node[feuille] (t2) {1}; ] 
        ]      
        \edge[white] node[auto=left] {0};[.\node[white] (c2) {c}; 
          \edge[white] node[auto=right] {1}; [.\node[feuille,white] (t3) {1}; ] \edge[white] node[auto=left] {0}; [.\node[feuille,white] (t4) {1}; ] 
        ] 
    ]
      \edge node[auto=left] {0}; [.b
        \edge node[auto=right] {1}; [.c 
          \edge node[auto=right] {1}; [.\node[feuille] (t5) {1}; ] \edge node[auto=left] {0}; [.\node[feuille] (t6) {1}; ] 
        ] 
        \edge node[auto=left] {0}; [.c 
          \edge node[auto=right] {1}; [.\node[feuille] {1}; ] \edge node[auto=left]  {0}; [.\node[feuille]{0}; ] 
        ]
    ] ]
        		\draw (a) -- node[above] {1} (t2);

        \onslide<2>{\draw[red,thick,dotted] ($(t1.north west)+(-0.3,0.6)$)  rectangle ($(t4.south east)+(0.3,-0.6)$);}
        \onslide<5>{\draw[red,thick,dotted] ($(t5.north west)+(-0.3,0.3)$)  rectangle ($(t6.south east)+(0.3,-0.3)$);}
\end{tikzpicture}}
\only<6-7>{\begin{tikzpicture}
[every tree node/.style={draw,circle},
   level distance=1.25cm,sibling distance=.5cm, 
   edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}]
\Tree [.\node (a) {a}; 
     \edge[white] node[auto=right] {1};[.\node[white] (b) {1};
        \edge[white];[.\node[white] (c) {c}; 
           \edge[white] node[auto=right] {1}; [.\node[feuille,white] (t1) {1}; ] \edge[white] node[auto=left] {0}; [.\node[feuille] (t2) {1}; ] 
        ]      
        \edge[white] node[auto=left] {0};[.\node[white] (c2) {c}; 
          \edge[white] node[auto=right] {1}; [.\node[feuille,white] (t3) {1}; ] \edge[white] node[auto=left] {0}; [.\node[feuille,white] (t4) {1}; ] 
        ] 
    ]
      \edge node[auto=left] {0}; [.\node (b2) {b};
        \edge node[auto=right] {1}; [.\node[feuille] (c4) {1};
          \edge[white] node[auto=right] {1}; [.\node[feuille,white] (t5) {1};] \edge[white] node[auto=left] {0}; [.\node[feuille,white] (t6) {1}; ] 
        ] 
        \edge node[auto=left] {0}; [.\node (c5) {c}; 
          \edge node[auto=right] {1}; [.\node[feuille] (t7) {1}; ] \edge node[auto=left]  {0}; [.\node[feuille] (t8) {0}; ] 
        ]
    ] ]
        \draw (a) -- node[above] {1} (t2);
        \onslide<2>{\draw[red,thick,dotted] ($(t1.north west)+(-0.3,0.6)$)  rectangle ($(t4.south east)+(0.3,-0.6)$);}
        \onslide<4>{\draw[red,thick,dotted] ($(t7.north west)+(-0.3,0.6)$)  rectangle ($(t8.south east)+(0.3,-0.6)$);}
        
        \onslide<7>{
        	\foreach \name in {t2,c4,t7}
        	  \draw[red,thick,dotted] ($(\name.north west)+(-0.3,0.3)$)  rectangle ($(\name.south east)+(0.3,-0.3)$);}        
\end{tikzpicture}}
\only<8->{\begin{tikzpicture}
[every tree node/.style={draw,circle},
   level distance=1.25cm,sibling distance=.5cm, 
   edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}]
\Tree [.\node (a) {a}; 
     \edge[white] node[auto=right] {1};[.\node[white] (b) {1};
        \edge[white];[.\node[white] (c) {c}; 
           \edge[white] node[auto=right] {1}; [.\node[feuille,white] (t1) {1}; ] \edge[white] node[auto=left] {0}; [.\node[feuille,white] (t2) {1}; ] 
        ]      
        \edge[white] node[auto=left] {0};[.\node[white] (c2) {c}; 
          \edge[white] node[auto=right] {1}; [.\node[feuille,white] (t3) {1}; ] \edge[white] node[auto=left] {0}; [.\node[feuille,white] (t4) {1}; ] 
        ] 
    ]
      \edge node[auto=left] {0}; [.\node (b2) {b};
        \edge[white] node[auto=right] {1}; [.\node[white] (c4) {1};
          \edge[white] node[auto=right] {1}; [.\node[feuille,white] (t5) {1};] \edge[white] node[auto=left] {0}; [.\node[feuille,white] (t6) {1}; ] 
        ] 
        \edge node[auto=left] {0}; [.\node (c5) {c}; 
          \edge node[auto=right] {1}; [.\node[feuille] (t7) {1}; ] \edge node[auto=left]  {0}; [.\node[feuille] (t8) {0}; ] 
        ]
    ] ]
    		\foreach \name in {a,b2}
    			\draw (\name) -- node[above] {1} (t7);
        \onslide<2>{\draw[red,thick,dotted] ($(t1.north west)+(-0.3,0.6)$)  rectangle ($(t4.south east)+(0.3,-0.6)$);}
        \onslide<4>{\draw[red,thick,dotted] ($(t7.north west)+(-0.3,0.6)$)  rectangle ($(t8.south east)+(0.3,-0.6)$);}
        
        \onslide<6>{
        	\foreach \name in {b,c4,t7}
        	  \draw[red,thick,dotted] ($(\name.north west)+(-0.3,0.3)$)  rectangle ($(\name.south east)+(0.3,-0.3)$);} 
    
\end{tikzpicture}}


  \end{overlayarea}


\end{frame}
\section{Representing  state sets with BDDs}
\begin{frame}
\frametitle{From a state set to a BDD}
	% BDDs use boolean vectors $\rightarrow$  states should be boolean vectors\\[0.5cm]\pause
 	
	
	 \begin{minipage}[t]{.50\linewidth}

State = (x,y) ($x,y\in \{0,1\}$)\\[0.3cm]	
	\begin{tikzpicture}
	\node[decision](d1) {};
	\foreach \rightof/\name in {d1/d2,d2/d3,d3/d4}{
		\node[decision,right of=\rightof] (\name) {};}
	\node[above of=d1] {init};
	\node[above of=d4] {goal};
	\foreach \couche/\pos/\name/\state in {2/d1/s1/00,3/d2/s2/01,4/d3/s3/10,5/d4/s4/11}{		
		\only<\couche>{\draw[red,fill=red] ($(\pos.north west)+(0.5,-0.5)$)  circle (0.1cm);
		\node[below of=\pos] (\name) {\state};}}
		
	\foreach \couche/\pos/\name/\state in {2/d1/s1/00,3/d2/s2/01,4/d3/s3/10,5/d4/s4/11}{		
		\only<6->{\node[below of=\pos] (\name) {\state};}}
	\end{tikzpicture}
\end{minipage}
\only<7->{
 \begin{minipage}[t]{.44\linewidth}
 \begin{center}
 
Initial state\\[0.3cm]

\begin{tikzpicture}
[every tree node/.style={draw,circle},
   level distance=1.25cm,sibling distance=.5cm, 
   edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}]
\Tree [.\node (x) {x};
	            \edge[white] node[auto=left] {1}; [.\node[white] {};]      
        \edge node[auto=left] {0};
        [.\node (y) {y}; 
          \edge node[auto=right] {1}; [.\node[feuille] (t3) {0}; ] 
          \edge node[auto=left] {0}; [.\node[feuille] (t4) {1}; ]    
     ]]
     
    \draw (x) -- node[left] {1} (t3);
\end{tikzpicture}

 \end{center}
\end{minipage}}


	\begin{itemize}	
	\item How do we represent a state ? A set of states ? A transition function ?
	\item Discussion about space efficency.
	\end{itemize}
\end{frame}

\section{Computing with BDDs}
\begin{frame}
\frametitle{Computing with BDDs}

\begin{itemize}
\item union
\item intersection
\item projection
\item quantification
\item time complexity of these operations
\end{itemize}

\end{frame}

\section{The BFS implemented with set operations}
\begin{frame}
\frametitle{The BFS implemented with set operations}

We perform a simple tree exploration.
\begin{description}
\item[\textsl{init}] is the initial state;
\item[\textsl{Goal}] is the set of goal states.
\end{description}

\begin{columns}[b]
	\begin{column}{.45\textwidth}
		\begin{algorithmic}
			\STATE{Open $\leftarrow$ \{init\}}
			\REPEAT
			  \STATE{Succ $\leftarrow$ Next(Open)}
			  \STATE{Open $\leftarrow$ Succ}
			\UNTIL{Open $\cap$ Goal $\neq \emptyset$}
			\RETURN{Build(Open $\cap$ Goal)}
		\end{algorithmic}
	\end{column}
	\pause
	\begin{column}{.65\textwidth}
	  \begin{algorithmic}
	  
		{\color<5-6>{gray}\color<handout>{black}
			\STATE{Open(x) $\leftarrow \Phi_{\{\t{init}\}}(x)$}
			\pause[3]
				\REPEAT
				  {\color{black}
				  \pause[5]
					  \STATE{$\t{Succ}(x') \leftarrow 
					    \exists x(\t{Open}(x) \land \t{Next}(x,x'))$}
					\pause[6]
					  \STATE{$\t{Open}(x)$ $\leftarrow \t{Succ}(x')
					    [x'\leftrightarrow{}x]$}
					}
				\pause[3]
				
				\UNTIL{$\t{Open}(x) \land\ \Phi_\t{Goal}(x) \neq \t{false}(x)$}
				\pause[4]
				\RETURN{Build(Open$(x) \land\ \Phi_\t{Goal}(x)$)}
		}
		\end{algorithmic}
	\end{column}
\end{columns}

\end{frame}

\section{Adaptation of classical algorithms}
\begin{frame}
\frametitle{Symbolic shortest path search (Dijkstra)}

We need to introduce Open(f,x) = true iff x is in the open list and has heuristic value f.

  	  \begin{algorithmic}

		%{\color<5-6>{gray}\color<handout>{black}
			\STATE{$\t{Open}(f,x) \leftarrow (f=0) \land \Phi_{\{\t{init}\}}(x)$}
			
				\LOOP
				
        \STATE{$f_\t{min} \leftarrow \min \{ f | \exists f' \cdot f = f' \land
                Open(f',x) \neq \t{false}(x)\} $}
        \STATE{$\t{Min}(x) \leftarrow \exists f(\t{Open}(f,x) \land 
                                              \lnot \t{Min}(x)$}
                                              
        \IF{$\t{Min}(x) \land\ \Phi_\t{Goal}(x) \neq \t{false}$}
				  \RETURN{$\t{Build}(\t{Min}(x) \land \Phi_\t{Goal}(x))$}
				\ENDIF				
        
				\STATE{$\t{Rest}(x) \leftarrow \t{Open}(f,x) \land \lnot\t{Min}(x)$}
				\STATE{$\t{Succ}(f,x)$ $\leftarrow 
				       \exists x,f',w \cdot$ 
				       $\phantom{} \hspace{2.2cm} ( \t{Min}(x) \land Trans(w,x,x') \land
				       f' = f_\t{min})[x \leftrightarrow x']$}
				\STATE{$\t{Open}(x) \leftarrow \t{Rest}(f,x) \lor \t{Succ}(f,x) $}
									
				\ENDLOOP
		%}
		\end{algorithmic}
\end{frame}

\begin{frame}
  	  \begin{algorithmic}

		%{\color<5-6>{gray}\color<handout>{black}
			\STATE{$\t{Open}(f,x) \leftarrow (f=0) \land \Phi_{\{\t{init}\}}(x)$}
			
				\LOOP
				
        \STATE{$f_\t{min} \leftarrow \min \{ f | \exists f' \cdot f = f' \land
                Open(f',x) \neq \t{false}(x)\} $}
        \STATE{$\t{Min}(x) \leftarrow \exists f(\t{Open}(f,x) \land 
                                              \lnot \t{Min}(x)$}
                                              
        \IF{$\t{Min}(x) \land\ \Phi_\t{Goal}(x) \neq \t{false}$}
				  \RETURN{$\t{Build}(\t{Min}(x) \land \Phi_\t{Goal}(x))$}
				\ENDIF				
        
				\STATE{$\t{Rest}(x) \leftarrow \t{Open}(f,x) \land \lnot\t{Min}(x)$}
				\STATE{$\t{Succ}(f,x)$ $\leftarrow 
				       \exists w,x,h,h',f' \cdot ( \t{Min}(x) \land Trans(w,x,x') \land
				       \t{Heur}(h,x) \land \t{Heur}(h',x') \land f'=f+w-h+h'
				       \land f' = f_\t{min})[x \leftrightarrow x']$}
				\STATE{$\t{Open}(x) \leftarrow \t{Rest}(f,x) \lor \t{Succ}(f,x) $}
									
				\ENDLOOP
		%}
		\end{algorithmic}

\end{frame}

\section{Fast pattern database with BBDs}
\begin{frame}
\frametitle{Fast pattern database with BBDs}

BDDs are an efficient way to implement pattern databases.
\begin{itemize}
\item What is a pattern database ?
\item How to implement it with BDDs ?
\item Is it really so efficient ?
\end{itemize}
\end{frame}

\section{Conclusion}
\begin{frame}
\frametitle{Conclusion}

\end{frame}

\end{document}